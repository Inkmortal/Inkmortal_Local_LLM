/**
 * Chat message service
 * 
 * Handles sending messages to the backend and receiving streaming responses
 * Supports WebSocket streaming with fallback to polling
 */
import { fetchApi } from '../../config/api';
import { 
  ChatRequestParams, 
  MessageStatus, 
  ChatResponse, 
  MessageStreamHandlers 
} from './types';
import { executeServiceCall, handleApiResponse } from './errorHandling';
import { 
  isWebSocketConnected, 
  waitForWebSocketConnection, 
  ensureWebSocketConnection,
  registerMessageId
} from './websocketService';

// Constants
const WS_CONNECTION_TIMEOUT_MS = 3000; // Wait up to 3 seconds for WS connection
const MESSAGE_POLL_INTERVAL_MS = 1000; // Poll every second when using polling mode

/**
 * Sends a chat message with optimal connection management
 * - Properly awaits WebSocket connection before sending
 * - Falls back to polling only when necessary
 * - Provides comprehensive streaming support
 * 
 * @param message The message content
 * @param conversationId The conversation ID
 * @param file Optional file data
 * @param handlers Streaming event handlers
 * @param assistantMessageId Optional assistant message ID generated by frontend
 * @returns Promise with the response message
 */
export async function sendChatMessage(
  message: string,
  conversationId: string,
  file: any = null,
  handlers: MessageStreamHandlers = {},
  assistantMessageId?: string
): Promise<ChatResponse> {
  // Extract handlers with defaults
  const { 
    onStart = () => {}, 
    onToken = () => {}, 
    onComplete = () => {}, 
    onError = () => {},
    onStatusUpdate = () => {}
  } = handlers;

  try {
    // Notify that we're starting
    onStart();
    onStatusUpdate(MessageStatus.QUEUED);
    
    // Get token from localStorage for WebSocket connection
    const token = localStorage.getItem('token') || localStorage.getItem('authToken');
    
    // Choose connection mode based on WebSocket availability
    let useWebSocket = isWebSocketConnected();
    
    // If not currently connected but we have a token, try to establish connection
    if (!useWebSocket && token) {
      console.log('[messageService] WebSocket not connected, attempting to establish connection');
      
      // Wait for connection with timeout
      useWebSocket = await waitForWebSocketConnection(token, WS_CONNECTION_TIMEOUT_MS);
      
      if (useWebSocket) {
        console.log('[messageService] Successfully established WebSocket connection');
      } else {
        console.warn('[messageService] Failed to establish WebSocket connection, falling back to polling');
      }
    }
    
    console.log(`[messageService] Using ${useWebSocket ? "WebSocket streaming" : "polling fallback"} for message delivery`);
    
    // Prepare request data
    const requestData: ChatRequestParams = {
      message,
      conversation_id: conversationId,
      mode: useWebSocket ? 'streaming' : 'polling',
      // CRITICAL: Always include assistant message ID for WebSocket message handling
      assistant_message_id: assistantMessageId || file?.assistantMessageId,
      // Explicitly set transport mode to control response delivery method
      transport_mode: useWebSocket ? 'websocket' : 'sse',
      // Add connection information to help backend distinguish WebSocket vs HTTP clients
      headers: useWebSocket ? {
        "Connection": "Upgrade",
        "Upgrade": "websocket"
      } : {}
    };
    
    // Add debug logging to verify the assistant_message_id is properly set
    console.log(`[messageService] Request prepared with assistant_message_id: ${requestData.assistant_message_id}`);
    
    // Verify assistant message ID is present for WebSocket transport
    if (useWebSocket && !requestData.assistant_message_id) {
      console.error("[messageService] CRITICAL ERROR: No assistant message ID for WebSocket transport!");
      // Generate a fallback ID to prevent null/undefined issues
      requestData.assistant_message_id = `fallback_${Date.now()}`;
      console.log(`[messageService] Generated fallback ID: ${requestData.assistant_message_id}`);
    }
    
    // We've already verified the assistant_message_id above, just log it now
    if (useWebSocket) {
      console.log(`[messageService] Using assistant message ID for streaming: ${requestData.assistant_message_id}`);
    }
    
    // Add file if provided
    if (file) {
      if (file.assistantMessageId) {
        // Store assistant message ID but don't include it in the file object
        const { assistantMessageId, ...fileData } = file;
        requestData.file = fileData;
      } else {
        requestData.file = file;
      }
    }
    
    // Send request and handle response
    try {
      // For WebSocket clients, handle differently to ensure message state maintenance
      if (useWebSocket) {
        try {
          // Send message request but don't care about detailed response content
          await fetchApi<ChatResponse>('/api/chat/message', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify(requestData),
          });
          
          console.log('WebSocket client - bypassing standard response processing');
        } catch (error) {
          // For WebSocket clients, log but continue - we want to maintain message state
          console.warn('HTTP error for WebSocket client, continuing with WebSocket streaming:', error);
          
          // CRITICAL: Log the assistant message ID we're expecting updates for
          console.log(`[messageService] CRITICAL! Expecting WebSocket updates for assistant_message_id: ${requestData.assistant_message_id}`);
          
          // Skip message ID registration here - we'll do it once after all error handling
        }
        
        // Always return success for WebSocket clients to maintain message state
        // Actual content will come via WebSocket updates
        
        // CRITICAL FIX: Only register the message ID once, after all error handling
        // This ensures we have a single consistent registration
        if (requestData.assistant_message_id && conversationId) {
          console.log(`[messageService] Registering WebSocket message ID mapping for: ${requestData.assistant_message_id}`);
          registerMessageId(
            requestData.assistant_message_id, // Frontend ID
            requestData.assistant_message_id, // Backend ID (same initially)
            conversationId
          );
        } else {
          console.error(`[messageService] CRITICAL ERROR: Cannot register message ID mapping - missing ID or conversation ID`);
        }
        
        const response = {
          success: true,
          message_id: requestData.assistant_message_id!, // Use the frontend-generated ID
          conversation_id: conversationId,
          assistant_message_id: requestData.assistant_message_id // Explicitly include assistant ID
        };
        
        // CRITICAL: Log the response to verify IDs match
        console.log(`[messageService] WebSocket client response with message_id: ${response.message_id} and assistant_message_id: ${response.assistant_message_id}`);
        
        return response;
      }
      
      // For non-WebSocket clients, use the normal flow with error handling
      const response = await fetchApi<ChatResponse>('/api/chat/message', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(requestData),
      });
      
      const result = handleApiResponse(response, {
        title: 'Message Error',
        notifyOnError: false, // We'll handle errors ourselves
      });
      
      if (!result.success) {
        throw new Error(result.error || 'Failed to send message');
      }
      
      // Now handle polling if needed
      if (!useWebSocket) {
        onStatusUpdate(MessageStatus.PROCESSING);
        
        // Get message ID from response
        const messageId = result.data?.id;
        
        // Handle case where backend doesn't provide a message ID
        if (!messageId) {
          console.warn("No message ID returned from backend - Ollama may be in use");
          
          // Create a synthetic message with the content we've received so far
          const dataContent = result.data?.content || '';
          const dataModel = result.data?.model || 'unknown';
          
          return {
            id: `synthetic_${Date.now()}`,
            conversation_id: conversationId,
            content: dataContent,
            created_at: new Date().toISOString(),
            role: 'assistant',
            status: 'complete',
            model: dataModel
          };
        }
        
        // Start polling for updates
        const completeMessage = await pollForMessageUpdates(
          messageId, 
          conversationId, 
          { onToken, onStatusUpdate, onError }
        );
        
        // When polling completes, notify completion handler
        onComplete(completeMessage);
        
        return completeMessage;
      }
      
      // When using WebSocket, just return a success object
      // WebSocket will handle the streaming updates
      return {
        success: true,
        message_id: result.data?.id,
        conversation_id: conversationId
      };
    } catch (error) {
      console.error('Error sending message:', error);
      onError(error instanceof Error ? error.message : 'Unknown error');
      throw error;
    }
  } catch (error) {
    console.error('Error in sendChatMessage:', error);
    onError(error instanceof Error ? error.message : 'Unknown error');
    throw error;
  }
}

/**
 * Polls for message updates when WebSocket is not available
 * @param messageId The message ID to poll for
 * @param conversationId The conversation ID
 * @param handlers Event handlers for streaming updates
 * @returns Promise with the complete message
 */
async function pollForMessageUpdates(
  messageId: string,
  conversationId: string,
  handlers: {
    onToken: (token: string) => void,
    onStatusUpdate: (status: MessageStatus, position?: number) => void,
    onError: (error: string) => void
  }
): Promise<ChatResponse> {
  const { onToken, onStatusUpdate, onError } = handlers;
  
  // Maximum polling attempts (10 minutes at 1 second intervals)
  const MAX_POLLING_ATTEMPTS = 600;
  
  // To track content across polling updates
  let currentContent = '';
  let lastContent = '';
  let attempts = 0;
  let isDone = false;
  
  // Continue polling until done or max attempts reached
  while (!isDone && attempts < MAX_POLLING_ATTEMPTS) {
    attempts++;
    
    try {
      // Wait for polling interval
      await new Promise(resolve => setTimeout(resolve, MESSAGE_POLL_INTERVAL_MS));
      
      // Verify we have both required IDs
      if (!conversationId || !messageId) {
        console.error(`Invalid IDs for message polling - conversationId: ${conversationId}, messageId: ${messageId}`);
        throw new Error('Missing required conversation or message ID for polling');
      }
      
      // Try the message-specific endpoint first
      let response;
      try {
        console.log(`Polling for message update: ${conversationId}/${messageId}`);
        response = await fetchApi<ChatResponse>(`/api/chat/message/${conversationId}/${messageId}`, {
          method: 'GET',
        });
      } catch (error) {
        // Fallback to conversation endpoint
        console.log(`Message-specific endpoint failed, trying conversation endpoint fallback`);
        response = await fetchApi<{messages: ChatResponse[]}>(`/api/chat/conversation/${conversationId}`, {
          method: 'GET',
        });
        
        // Extract the specific message we're interested in
        if (response && response.ok) {
          const data = await response.json();
          if (data.messages && Array.isArray(data.messages)) {
            const targetMessage = data.messages.find(msg => msg.id === messageId);
            if (targetMessage) {
              // Create a new response with just the message we want
              response = new Response(JSON.stringify(targetMessage), {
                status: 200,
                headers: response.headers
              });
            } else {
              console.error(`Message ${messageId} not found in conversation data`);
              throw new Error(`Message not found in conversation data`);
            }
          } else {
            console.error(`Invalid conversation response format - missing messages array`);
            throw new Error(`Invalid conversation response format`);
          }
        }
      }
      
      // Process response without notifications
      const result = handleApiResponse(response, {
        title: 'Message Error',
        notifyOnError: false,
      });
      
      if (!result.success) {
        throw new Error(result.error || 'Failed to get message update');
      }
      
      const update = result.data;
      
      // Check for completion
      if (update.status === 'complete') {
        isDone = true;
        onStatusUpdate(MessageStatus.COMPLETE);
        return update;
      }
      
      // Check for error
      if (update.status === 'error') {
        isDone = true;
        onStatusUpdate(MessageStatus.ERROR);
        onError(update.error || 'Error generating response');
        return update;
      }
      
      // Update status
      if (update.status === 'processing') {
        onStatusUpdate(MessageStatus.PROCESSING, update.queue_position);
      } else if (update.status === 'streaming') {
        onStatusUpdate(MessageStatus.STREAMING);
      }
      
      // Calculate token update by comparing with previous content
      if (update.content && update.content !== lastContent) {
        const newContent = update.content;
        const tokenUpdate = newContent.substring(currentContent.length);
        
        if (tokenUpdate) {
          onToken(tokenUpdate);
          currentContent = newContent;
          lastContent = newContent;
        }
      }
    } catch (error) {
      console.error('Error polling for message update:', error);
      // Don't give up on a single error, just continue polling
    }
  }
  
  // If we reach max attempts, consider it an error
  if (!isDone) {
    onStatusUpdate(MessageStatus.ERROR);
    onError('Timed out waiting for message completion');
    throw new Error('Timed out waiting for message completion');
  }
  
  // This shouldn't be reached, but satisfy the TypeScript return type
  return {
    id: messageId,
    conversation_id: conversationId,
    content: currentContent,
    created_at: new Date().toISOString(),
    role: 'assistant',
    status: 'complete'
  };
}

/**
 * Regenerates a specific message
 * @param messageId The message ID to regenerate
 * @param conversationId The conversation ID
 * @param handlers Streaming event handlers
 * @returns Promise with the regenerated message
 */
export async function regenerateMessage(
  messageId: string,
  conversationId: string,
  handlers: MessageStreamHandlers = {}
): Promise<ChatResponse> {
  return executeServiceCall(
    async () => {
      const response = await fetchApi<ChatResponse>(`/api/chat/message/${conversationId}/${messageId}/regenerate`, {
        method: 'POST',
      });
      
      const result = handleApiResponse(response, {
        title: 'Regeneration Failed',
        notifyOnError: false,
      });
      
      if (!result.success) {
        throw new Error(result.error || 'Failed to regenerate message');
      }
      
      return result.data;
    },
    {} as ChatResponse,
    handlers.onError
  );
}